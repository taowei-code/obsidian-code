1、从 JS 诞生依赖的开发讲起，走 JS 文件调用越来越复杂，人们开始试图通过 html 文件来初步组织“模块化”的代码，但是为啥我 JS 模块化要依赖于你 HTML，同时，对于程序的加载顺序和全局污染也带来了迫切的需求；（这个全局污染是不是被 Java 的封装降维打击了？）

2、于是，nodejs 创新的搞出了模块化，给开发者带来了前所未有的体验；CommonJS 规范应运而生！但是，nodejs 是服务器端，受限于过去生态中浏览器各家厂商谁看谁不顺眼，浏览器端怎么办？模块化多好啊

3、于是，AMD YES！而 RequireJS 就是实现这个 AMD 规范的最佳范例，看代码的组织逻辑，确实过去的技术并不代表落后，我还是很喜欢 RequireJS 的代码组织逻辑和结构，感觉很像 JAVA。（规范足够强，工程性就足够强！）

4、同时，阿里也为程序员搞出了 CMD 规划，通用模块定义，实现方式是 seajs。但是和 requirejs 相比，cmd 是依赖就近，而 AMD 是依赖前置，这是个效率问题的改进。

5、最终，ECMA“迫于压力”，为了程序员的幸福工作，推出了 ES6 模块化规范，import export！

6、但是 CommonJS 和 ES6 模块由本质的区别，CommonJS 是拷贝，类似于类的对象；而 ES6 是直接的引用；所以，一个是运行时加载，一个是编译时加载（当然这句话的理解还是停留在表面）；

总结：

模块化其实本质解决的是加载顺序和全局污染，当然还有代码复用等程序员开发遇到的现实问题；

模块化最初尝试由 nodejs 提出，但是你不能只服务端啊，浏览器端也需要啊，于是 AMD 和 CMD 规范诞生；

模块化这个工作，其实更应该是 EMCA 来搞啊，可惜你没想到 web 发展如此之快，也没想到浏览器霸主 ie 掉落神坛了，于是迫于压力，推出了 ES6 模块化（甚至想搞类 Class 也搞的不伦不类）。

  
  
  
  
  
  
  
  
  

1. JS 越来越多，单独写到一个文件里，最初的模块化概念

  
  

2. 公用模块的问题，A 页面需要公用模块的所有方法，B 模块只需要一个，这就涉及到了依赖问题

   总结：不能以页面为基础来分 JS 模块

  

3. 引入多个文件，每个文件作为一个模块

  

加载顺序问题

变量覆盖、变量重名 -> 污染全局

  

所以模块化最开始要解决的问题：

  

1. 加载顺序

2. 污染全局

  
  

发展：

  

立即执行函数解决作用域的问题

  
  
  

一个函数声明不是表达式，只要不是表达式，就一定不可以在后面加执行符号

function fn () {}

  

JS中，只要加上括号变会成表达式

(function fn () {})()

  

立即执行函数，可以不需要函数名

  

打分号的原因，浏览器不识别

(function fn () {})()

(function fn () {})()

(function fn () {})()

  

规范

;(function(){

  

})();

  

利用立即执行函数写插件也是模块化一种表现